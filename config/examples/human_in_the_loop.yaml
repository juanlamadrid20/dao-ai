# yaml-language-server: $schema=../../schemas/model_config_schema.json

# =============================================================================
# Human in the Loop (HITL) Configuration Example
# =============================================================================
# This configuration demonstrates how to use Human in the Loop approval 
# for tool executions. HITL pauses agent execution before tool calls,
# allowing humans to approve, edit, respond with context, or decline.
#
# Key Features:
# - Tool-level configuration via human_in_the_loop field
# - Customizable review prompts and decline messages  
# - Fine-grained control over allowed actions (accept/edit/respond/decline)
# - Works with all tool types (python, factory, unity_catalog, mcp)
# - Requires a checkpointer to be configured for persistence

# =============================================================================
# VARIABLES
# =============================================================================
# Define reusable variables that can be referenced throughout the config
# using YAML anchors (&variable_name) and aliases (*variable_name)

variables:
  # SMTP credentials from environment variables with defaults
  # These can be reused across multiple tools or resources
  smtp_username: &smtp_username
    env: SMTP_USER
  
  smtp_password: &smtp_password
    env: SMTP_PASSWORD

  smtp_sender_email: &smtp_sender_email
    env: SMTP_SENDER_EMAIL
  
  # Other variable types supported:
  # - Secrets: { type: secret, scope: my_scope, key: my_key }
  # - Composite: { type: composite, options: [${VAR1}, ${VAR2}, default] }
  # - Primitives: Just use the value directly

schemas:
  retail_schema: &retail_schema
    catalog_name: nfleming                    
    schema_name: retail_ai                    

resources:
  llms:
    default_llm: &default_llm
      name: databricks-meta-llama-3-3-70b-instruct 
      temperature: 0.1
      max_tokens: 8192


# =============================================================================
# TOOLS WITH HUMAN-IN-THE-LOOP CONFIGURATIONS
# =============================================================================

tools:
  # Example 1: Factory function with full HITL configuration
  send_email: &send_email
    name: send_email
    function:
      type: factory
      name: dao_ai.tools.email.create_send_email_tool
      args:
        smtp_config:
          host: smtp.gmail.com           # Or use ${SMTP_HOST}
          port: 587                      # Or use ${SMTP_PORT}
          username: *smtp_username       # Reference to variable (env: SMTP_USER)
          password: *smtp_password       # Reference to variable (env: SMTP_PASSWORD)
          # Alternative: Use Databricks secrets directly
          # password:
          #   type: secret
          #   scope: email-credentials
          #   key: smtp_password
          sender_email: *smtp_sender_email  # Or use ${SENDER_EMAIL}
          use_tls: true
      # Full HITL configuration with custom review prompt
      human_in_the_loop:
        review_prompt: |
          Please review this email before sending.
          Verify the recipient, subject, and content are appropriate.
        interrupt_config:
          allow_accept: true    # Allow approving without changes
          allow_edit: true      # Allow editing before execution
          allow_respond: true   # Allow providing additional context
          allow_decline: true   # Allow rejecting the tool call
        decline_message: "Email sending declined by user"
        custom_actions:
          approve_and_send: "Approve and send immediately"
          schedule: "Schedule for later"




  # Example 5: Tool WITHOUT HITL (for comparison)
  current_time: &current_time
    name: current_time
    function:
      type: python
      name: dao_ai.tools.current_time_tool
      # No human_in_the_loop configured - executes immediately



# =============================================================================
# AGENTS WITH HITL-ENABLED TOOLS
# =============================================================================

agents:
  # Agent with high-risk tools requiring approval
  admin_agent: &admin_agent
    name: admin_agent
    description: "Administrative agent with HITL-protected operations"
    model: *default_llm
    tools:
      - *send_email        # Requires approval
      - *current_time      # No approval needed (safe)
    prompt: |
      You are an administrative agent with access to sensitive operations.
      
      IMPORTANT: All destructive or external operations require human approval.
      When you want to:
      - Send emails
      - Delete records
      - Execute SQL
      
      The system will pause and ask for human review. Wait for approval.
      
      Safe operations (like current_time) execute immediately without approval.

# =============================================================================
# MEMORY CONFIGURATION (REQUIRED FOR HITL)
# =============================================================================
# HITL requires a checkpointer to persist state between approval steps
# Using memory type for this example - use postgres/lakebase in production

memory: &memory
  checkpointer: 
    name: hitl_checkpointer
    type: memory             # For production, use postgres or lakebase with database config
  store:
    name: hitl_store
    type: memory

# =============================================================================
# APPLICATION CONFIGURATION
# =============================================================================

app:

  name: hitl_demo_app
  description: "Demonstration of Human in the Loop approvals"
  log_level: DEBUG
  
  registered_model:
    schema: *retail_schema
    name: hitl_demo_app
  
  endpoint_name: hitl_demo_app
  
  agents:
    - *admin_agent

  
  orchestration:
    supervisor:
      model: *default_llm
      # You can also add HITL to supervisor tools if needed
      tools: []
    memory: *memory  # CRITICAL: Memory with checkpointer required for HITL
  
  input_example:
    messages:
      - role: user
        content: "Send an email to the team about tomorrow's meeting"
    custom_inputs:
      configurable:
        user_id: demo_user
        thread_id: demo_thread
      session: {}

# =============================================================================
# USAGE NOTES
# =============================================================================
# 
# 1. HITL Workflow:
#    a. Agent decides to call a tool with human_in_the_loop configured
#    b. Execution pauses (interrupt) with review_prompt displayed
#    c. Human reviews and chooses action:
#       - Accept: Execute tool with original arguments
#       - Edit: Modify arguments before execution
#       - Respond: Provide context/feedback to agent without executing
#       - Decline: Cancel tool call with decline_message
#    d. Agent continues with human's decision
#
# 2. Checkpointer Requirement:
#    HITL requires a checkpointer to save state during interrupts.
#    This example uses memory type for simplicity.
#    For production, configure postgres or lakebase with database settings:
#      checkpointer:
#        type: postgres  # or lakebase
#        database:
#          host: your-postgres-host
#          port: 5432
#          database: your_db_name
#
# 3. Action Controls:
#    Fine-tune allowed actions per tool via interrupt_config:
#    - allow_accept: Approve and execute
#    - allow_edit: Modify before execution
#    - allow_respond: Give feedback without executing
#    - allow_decline: Cancel the tool call
#
# 4. Best Practices:
#    - Use HITL for: destructive operations, external APIs, costly operations
#    - Skip HITL for: read-only operations, simple utilities, time-sensitive tasks
#    - Write clear review_prompts explaining what needs review
#    - Provide helpful decline_messages for rejected operations
#
# 5. Testing HITL:
#    When testing, the agent will pause at HITL-enabled tools.
#    Use LangGraph's interrupt handling to simulate human decisions.
#
# 6. Production Deployment:
#    HITL works in Model Serving with proper UI integration.
#    The review_prompt and options are returned to the client.
#    Client UI collects human decision and continues the graph.
